<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>board</title>
</head>
<body>
    <h1>Whatever</h1>
    <!-- List 출력 ul : unordered list, ol : ordered list, li : list -->
    <ul><a href="#1">1.</a> 개요</ul>
    <ul><a href="#2">2.</a> 특징</ul>
    <ul><a href="#3">3.</a> 기술</ul>
    
    <h2 id = "1">개요 <a href="#">Top</a></h2>
    
    <pre>
        <!-- blockquote : 인용문을 나타낼 때 -->
        <blockquote>Fight!!!</blockquote>
        <code><strong><i>System.out.println("조진호")</i></strong></code><br>
        In this program, it is possible that the object aObj in File1.cpp gets initialized before bObj in File2.cpp. That is all good since in that case, the constructor for bObj runs after aObj has been constructed. It is safe to call call methods on aObj.

        But it is also possible that the object bObj in File2.cpp gets initialized before aObj in File1.cpp. In that case, the constructor of bObj calls doSomething() on aObj which has not been constructed! The memory has been allocated for aObj, but it hasn't been constructed. This could lead to unintended behavior / a corrupt program.

        So this is what the static initialization order fiasco is all about.

        But we're not done: the other problem is the static de-initialization order fiasco! This is pretty much the same problem, just applied to the order of de-initialization of static objects.

        The C++ standard doesn't specify the order in which static objects get de-initialized as well. So it is possible that static object aObj gets destroyed before bObj. This is a problem if bObj's destructor uses or references aObj.
        In this program, it is possible that the object aObj in File1.cpp gets initialized before bObj in File2.cpp. That is all good since in that case, the constructor for bObj runs after aObj has been constructed. It is safe to call call methods on aObj.

        But it is also possible that the object bObj in File2.cpp gets initialized before aObj in File1.cpp. In that case, the constructor of bObj calls doSomething() on aObj which has not been constructed! The memory has been allocated for aObj, but it hasn't been constructed. This could lead to unintended behavior / a corrupt program.

        So this is what the static initialization order fiasco is all about.

        But we're not done: the other problem is the static de-initialization order fiasco! This is pretty much the same problem, just applied to the order of de-initialization of static objects.

        The C++ standard doesn't specify the order in which static objects get de-initialized as well. So it is possible that static object aObj gets destroyed before bObj. This is a problem if bObj's destructor uses or references aObj.
        In this program, it is possible that the object aObj in File1.cpp gets initialized before bObj in File2.cpp. That is all good since in that case, the constructor for bObj runs after aObj has been constructed. It is safe to call call methods on aObj.

        But it is also possible that the object bObj in File2.cpp gets initialized before aObj in File1.cpp. In that case, the constructor of bObj calls doSomething() on aObj which has not been constructed! The memory has been allocated for aObj, but it hasn't been constructed. This could lead to unintended behavior / a corrupt program.

        So this is what the static initialization order fiasco is all about.

        But we're not done: the other problem is the static de-initialization order fiasco! This is pretty much the same problem, just applied to the order of de-initialization of static objects.

        The C++ standard doesn't specify the order in which static objects get de-initialized as well. So it is possible that static object aObj gets destroyed before bObj. This is a problem if bObj's destructor uses or references aObj.
    </pre>
    <hr>
    <h2 id = "2">특징 <a href="#">Top</a></h2>
    <pre>
        In this program, it is possible that the object aObj in File1.cpp gets initialized before bObj in File2.cpp. That is all good since in that case, the constructor for bObj runs after aObj has been constructed. It is safe to call call methods on aObj.
            
        But it is also possible that the object bObj in File2.cpp gets initialized before aObj in File1.cpp. In that case, the constructor of bObj calls doSomething() on aObj which has not been constructed! The memory has been allocated for aObj, but it hasn't been constructed. This could lead to unintended behavior / a corrupt program.

        So this is what the static initialization order fiasco is all about.

        But we're not done: the other problem is the static de-initialization order fiasco! This is pretty much the same problem, just applied to the order of de-initialization of static objects.

        The C++ standard doesn't specify the order in which static objects get de-initialized as well. So it is possible that static object aObj gets destroyed before bObj. This is a problem if bObj's destructor uses or references aObj.
        In this program, it is possible that the object aObj in File1.cpp gets initialized before bObj in File2.cpp. That is all good since in that case, the constructor for bObj runs after aObj has been constructed. It is safe to call call methods on aObj.
            
        But it is also possible that the object bObj in File2.cpp gets initialized before aObj in File1.cpp. In that case, the constructor of bObj calls doSomething() on aObj which has not been constructed! The memory has been allocated for aObj, but it hasn't been constructed. This could lead to unintended behavior / a corrupt program.

        So this is what the static initialization order fiasco is all about.

        But we're not done: the other problem is the static de-initialization order fiasco! This is pretty much the same problem, just applied to the order of de-initialization of static objects.

        The C++ standard doesn't specify the order in which static objects get de-initialized as well. So it is possible that static object aObj gets destroyed before bObj. This is a problem if bObj's destructor uses or references aObj.
        In this program, it is possible that the object aObj in File1.cpp gets initialized before bObj in File2.cpp. That is all good since in that case, the constructor for bObj runs after aObj has been constructed. It is safe to call call methods on aObj.
            
        But it is also possible that the object bObj in File2.cpp gets initialized before aObj in File1.cpp. In that case, the constructor of bObj calls doSomething() on aObj which has not been constructed! The memory has been allocated for aObj, but it hasn't been constructed. This could lead to unintended behavior / a corrupt program.

        So this is what the static initialization order fiasco is all about.

        But we're not done: the other problem is the static de-initialization order fiasco! This is pretty much the same problem, just applied to the order of de-initialization of static objects.

        The C++ standard doesn't specify the order in which static objects get de-initialized as well. So it is possible that static object aObj gets destroyed before bObj. This is a problem if bObj's destructor uses or references aObj.
    </pre>
    <hr>
    <h2 id = "3">기술 <a href="#">Top</a></h2>
    <pre>
        In this program, it is possible that the object aObj in File1.cpp gets initialized before bObj in File2.cpp. That is all good since in that case, the constructor for bObj runs after aObj has been constructed. It is safe to call call methods on aObj.

        But it is also possible that the object bObj in File2.cpp gets initialized before aObj in File1.cpp. In that case, the constructor of bObj calls doSomething() on aObj which has not been constructed! The memory has been allocated for aObj, but it hasn't been constructed. This could lead to unintended behavior / a corrupt program.

        So this is what the static initialization order fiasco is all about.

        But we're not done: the other problem is the static de-initialization order fiasco! This is pretty much the same problem, just applied to the order of de-initialization of static objects.

        The C++ standard doesn't specify the order in which static objects get de-initialized as well. So it is possible that static object aObj gets destroyed before bObj. This is a problem if bObj's destructor uses or references aObj.
        In this program, it is possible that the object aObj in File1.cpp gets initialized before bObj in File2.cpp. That is all good since in that case, the constructor for bObj runs after aObj has been constructed. It is safe to call call methods on aObj.

        But it is also possible that the object bObj in File2.cpp gets initialized before aObj in File1.cpp. In that case, the constructor of bObj calls doSomething() on aObj which has not been constructed! The memory has been allocated for aObj, but it hasn't been constructed. This could lead to unintended behavior / a corrupt program.

        So this is what the static initialization order fiasco is all about.

        But we're not done: the other problem is the static de-initialization order fiasco! This is pretty much the same problem, just applied to the order of de-initialization of static objects.

        The C++ standard doesn't specify the order in which static objects get de-initialized as well. So it is possible that static object aObj gets destroyed before bObj. This is a problem if bObj's destructor uses or references aObj.
        In this program, it is possible that the object aObj in File1.cpp gets initialized before bObj in File2.cpp. That is all good since in that case, the constructor for bObj runs after aObj has been constructed. It is safe to call call methods on aObj.

        But it is also possible that the object bObj in File2.cpp gets initialized before aObj in File1.cpp. In that case, the constructor of bObj calls doSomething() on aObj which has not been constructed! The memory has been allocated for aObj, but it hasn't been constructed. This could lead to unintended behavior / a corrupt program.

        So this is what the static initialization order fiasco is all about.

        But we're not done: the other problem is the static de-initialization order fiasco! This is pretty much the same problem, just applied to the order of de-initialization of static objects.

        The C++ standard doesn't specify the order in which static objects get de-initialized as well. So it is possible that static object aObj gets destroyed before bObj. This is a problem if bObj's destructor uses or references aObj.
        In this program, it is possible that the object aObj in File1.cpp gets initialized before bObj in File2.cpp. That is all good since in that case, the constructor for bObj runs after aObj has been constructed. It is safe to call call methods on aObj.

        But it is also possible that the object bObj in File2.cpp gets initialized before aObj in File1.cpp. In that case, the constructor of bObj calls doSomething() on aObj which has not been constructed! The memory has been allocated for aObj, but it hasn't been constructed. This could lead to unintended behavior / a corrupt program.

        So this is what the static initialization order fiasco is all about.

        But we're not done: the other problem is the static de-initialization order fiasco! This is pretty much the same problem, just applied to the order of de-initialization of static objects.

        The C++ standard doesn't specify the order in which static objects get de-initialized as well. So it is possible that static object aObj gets destroyed before bObj. This is a problem if bObj's destructor uses or references aObj.
    </pre>
    

</body>
</html>